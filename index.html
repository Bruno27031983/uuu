<!DOCTYPE html>
<html lang="sk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bruno's Calculator Pro (K칩d 1 - Logovanie)</title> <!-- Zmenen칳 titulok pre identifik치ciu -->

  <link rel="manifest" href="./manifest.json" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>游빑</text></svg>">
  <link rel="apple-touch-icon" href="./icons/icon-192x192.png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.15/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>

  <style>
    /* CSS zost치va rovnak칠 */
    :root {
      --primary-bg-color: #f0f2f5; /* ... at캞 ... */
      --transition-speed: 0.2s;
    }
    /* ... (cel칳 v치코 CSS k칩d) ... */
    @media print {
      /* ... (v치코 print CSS) ... */
      .current-day span[aria-hidden="true"], #workDays td:nth-child(1) span[aria-hidden="true"] { display: none !important; }
    }
  </style>
</head>
<body>
  <!-- HTML 코trukt칰ra zost치va rovnak치 -->
  <div class="container">
    <!-- ... (cel칳 v치코 HTML k칩d) ... -->
  </div>

  <div id="saveNotification" role="status" aria-live="polite">D치ta boli 칰spe코ne ulo쬰n칠.</div>
  <div id="errorNotification" role="alert" aria-live="assertive">Nastala chyba.</div>
  <div id="warningNotification" role="alert" aria-live="assertive">Upozornenie.</div>

  <script type="module">
    // --- LOGGING PREFIX (pre 쬬h코ie filtrovanie v konzole) ---
    const LOG_PREFIX = "[KOD_1_DEBUG] ";

    // Importy Firebase - verzia 9.22.1
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js';
    import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js';
    import {
        initializeFirestore, persistentLocalCache, CACHE_SIZE_UNLIMITED,
        collection, doc, setDoc, getDoc, updateDoc, deleteDoc, onSnapshot, writeBatch,
        enableNetwork, disableNetwork // Pridan칠 pre experiment치lne riadenie siete
    } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore.js';
    import { initializeAppCheck, ReCaptchaV3Provider } from 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app-check.js';

   const firebaseConfig = {
        apiKey: "AIzaSyBdLtJlduT3iKiGLDJ0UfAakpf6wcresnk",
        authDomain: "uuuuu-f7ef9.firebaseapp.com",
        projectId: "uuuuu-f7ef9",
        storageBucket: "uuuuu-f7ef9.appspot.com",
        messagingSenderId: "456105865458",
        appId: "1:456105865458:web:101f0a4dcb455f174b606b",
    };

    console.log(LOG_PREFIX + "Initializing Firebase app...");
    const app = initializeApp(firebaseConfig);
    try {
       const appCheck = initializeAppCheck(app, {
            provider: new ReCaptchaV3Provider('6LczmP0qAAAAAACGalBT9zZekkUr3hLgA2e8o99v'),
            isTokenAutoRefreshEnabled: true
        });
        console.log(LOG_PREFIX + "Firebase App Check initialized.");
    } catch (e) {
        console.warn(LOG_PREFIX + "App Check initialization failed:", e);
    }
    const auth = getAuth(app);

    let db;
    try {
        console.log(LOG_PREFIX + "Initializing Firestore with persistent local cache...");
        db = initializeFirestore(app, {
            localCache: persistentLocalCache({ sizeBytes: CACHE_SIZE_UNLIMITED })
            // experimentalForceLongPolling: true, // Ak chcete testova콘 s long pollingom
        });
        console.log(LOG_PREFIX + "Firestore initialized with persistent local cache enabled.");
    } catch (error) {
        console.error(LOG_PREFIX + "Error initializing Firestore with persistent cache:", error);
        db = initializeFirestore(app, {});
        showErrorNotification("Chyba pri inicializ치cii offline 칰lo쬴ska.");
    }

    // --- Glob치lne Premenn칠 a UI Referencie (bez zmien) ---
    let currentUser = null; /* ... (ostatn칠 glob치lne premenn칠) ... */
    const uiRefs = { /* ... (va코e UI referencie) ... */ };
    // ... (appSettings, MONTH_NAMES, DAY_NAMES_SHORT) ...

    // --- Utility Funkcie (bez zmien, okrem showNotification, ktor치 u m치 LOG_PREFIX v pr칤pade chyby) ---
    function showNotification(id, message, duration = 3500) {
        const notification = document.getElementById(id);
        if (!notification) { console.error(LOG_PREFIX + `Notification element with ID '${id}' not found.`); return; }
        // ... (zvy코ok funkcie)
    }
    // ... (getDaysInMonth, getDayName, isWeekend, debounce, isValidTimeFormat, setLoadingState) ...

    // --- Spr치va Nastaven칤 Aplik치cie (pridan칠 logovanie) ---
    async function saveAppSettingsToFirestore() {
        console.log(LOG_PREFIX + "saveAppSettingsToFirestore: Called.");
        if (!currentUser) { console.log(LOG_PREFIX + "saveAppSettingsToFirestore: Aborted - No user."); return; }
        if (!navigator.onLine) { console.log(LOG_PREFIX + "saveAppSettingsToFirestore: Aborted - Offline."); return; }
        // ... (zvy코ok funkcie s logovan칤m 칰spechu/chyby)
        try {
            await setDoc(doc(db, 'users', currentUser.uid), { appSettings: appSettings }, { merge: true });
            console.log(LOG_PREFIX + "saveAppSettingsToFirestore: Settings saved to Firestore.");
        } catch (error) {
            console.error(LOG_PREFIX + "saveAppSettingsToFirestore: Error saving settings:", error);
            showErrorNotification("Nepodarilo sa ulo쬴콘 nastavenia aplik치cie do cloudu.");
        }
    }
    // ... (ostatn칠 funkcie pre nastavenia s pr칤padn칳m logovan칤m)

    // --- Firebase Autentifik치cia (pridan칠 logovanie za캜iatku/konca funkci칤) ---
    window.loginUser = async function() {
        console.log(LOG_PREFIX + "loginUser: Called.");
        // ... (zvy코ok funkcie s logovan칤m 칰spechu/chyby)
    };
    // ... (registerUser, createUserCollectionAndSettings, logoutUser, resetUserPassword s logovan칤m)

    // --- Spr치va Mesa캜n칳ch D치t a Synchroniz치cia (k쮂줷꼂v칠 logovanie) ---
    function setupFirestoreWorkDataListener() {
        console.log(LOG_PREFIX + `setupFirestoreWorkDataListener: Called for ${getFirestoreDocId()}.`);
        if (currentListenerUnsubscribe) {
            console.log(LOG_PREFIX + "setupFirestoreWorkDataListener: Unsubscribing previous listener.");
            currentListenerUnsubscribe();
            currentListenerUnsubscribe = null;
        }
        if (!currentUser) { console.log(LOG_PREFIX + "setupFirestoreWorkDataListener: Aborted - No user. Loading from LS."); loadWorkDataFromLocalStorage(); return; }
        if (!navigator.onLine) { console.log(LOG_PREFIX + "setupFirestoreWorkDataListener: Aborted - Offline. Loading from LS."); loadWorkDataFromLocalStorage(); return; }

        const docId = getFirestoreDocId();
        const docRef = doc(db, 'users', currentUser.uid, 'workData', docId);
        console.log(LOG_PREFIX + `setupFirestoreWorkDataListener: Attaching ON_SNAPSHOT listener for document: users/${currentUser.uid}/workData/${docId}`);

        currentListenerUnsubscribe = onSnapshot(docRef, (docSnap) => {
            console.log(LOG_PREFIX + `ON_SNAPSHOT (${docId}): Received. HasPendingWrites: ${docSnap.metadata.hasPendingWrites}, FromCache: ${docSnap.metadata.fromCache}, Source: ${docSnap.metadata.fromCache ? 'cache' : 'server'}`);
            const localKey = getLocalStorageKeyForWorkData();
            if (docSnap.exists()) {
                const firestoreData = docSnap.data();
                const firestoreDataString = JSON.stringify(firestoreData);
                if (!docSnap.metadata.hasPendingWrites || firestoreDataString !== localStorage.getItem(localKey)) {
                    console.log(LOG_PREFIX + `ON_SNAPSHOT (${docId}): Document exists. Applying data to UI and LS.`);
                    localStorage.setItem(localKey, firestoreDataString);
                    parseAndApplyWorkData(firestoreDataString);
                } else {
                    console.log(LOG_PREFIX + `ON_SNAPSHOT (${docId}): Data is local echo or matches LS. Calculating total.`);
                    calculateTotal();
                }
            } else {
                console.log(LOG_PREFIX + `ON_SNAPSHOT (${docId}): Document does NOT exist. Clearing LS and UI.`);
                if (localStorage.getItem(localKey)) localStorage.removeItem(localKey);
                parseAndApplyWorkData(null);
            }
        }, (error) => {
            console.error(LOG_PREFIX + `ON_SNAPSHOT_ERROR (${docId}):`, error);
            showErrorNotification(`Chyba synchroniz치cie: ${error.message}. Zobrazujem lok치lne d치ta.`);
            loadWorkDataFromLocalStorage();
        });
        // Po nastaven칤 listenera, sk칰sime synchronizova콘 pr칤padn칠 캜akaj칰ce d치ta
        console.log(LOG_PREFIX + "setupFirestoreWorkDataListener: Calling syncPendingWorkData after listener setup.");
        syncPendingWorkData(); // Zavol치me hne캞 po nastaven칤 listenera
    }

    const _debouncedSaveWorkDataAndSync = debounce(() => {
        console.log(LOG_PREFIX + "_debouncedSaveWorkDataAndSync: Called.");
        const dataToSave = collectWorkDataForStorage();
        const localKey = getLocalStorageKeyForWorkData();
        localStorage.setItem(localKey, JSON.stringify(dataToSave));
        updateLocalStorageSizeIndicator();
        console.log(LOG_PREFIX + "_debouncedSaveWorkDataAndSync: Work data saved to LocalStorage.");

        if (currentUser && navigator.onLine) {
            console.log(LOG_PREFIX + "_debouncedSaveWorkDataAndSync: User online, calling saveWorkDataToFirestore.");
            saveWorkDataToFirestore(dataToSave, getFirestoreDocId());
        } else if (currentUser) {
            const pendingKey = getPendingSyncKeyForWorkData();
            localStorage.setItem(pendingKey, JSON.stringify(dataToSave));
            console.log(LOG_PREFIX + `_debouncedSaveWorkDataAndSync: User offline, data marked for pending sync with key: ${pendingKey}.`);
            // Tu by sa mohol vola콘 markDataForSyncAndRegisterTag() pre Background Sync
        }
        calculateTotal();
    }, 1200);
    window.debouncedSaveWorkDataAndSync = _debouncedSaveWorkDataAndSync;

    async function saveWorkDataToFirestore(dataToSave, docId) {
        console.log(LOG_PREFIX + `saveWorkDataToFirestore (${docId}): Called.`);
        if (!currentUser) { console.log(LOG_PREFIX + `saveWorkDataToFirestore (${docId}): Aborted - No user.`); return; }
        if (!navigator.onLine) { console.log(LOG_PREFIX + `saveWorkDataToFirestore (${docId}): Aborted - Offline (should be caught by caller, but double check).`); return; }

        const docRef = doc(db, 'users', currentUser.uid, 'workData', docId);
        try {
            console.log(LOG_PREFIX + `saveWorkDataToFirestore (${docId}): Attempting to setDoc... Payload size: ~${JSON.stringify(dataToSave).length} bytes.`);
            await setDoc(docRef, dataToSave, { merge: true });
            console.log(LOG_PREFIX + `saveWorkDataToFirestore (${docId}): Work data successfully saved to Firestore.`);
            const pendingKey = getPendingSyncKeyForWorkData();
            if (pendingKey && localStorage.getItem(pendingKey)) { // Kontrola, 캜i pendingKey existuje predt칳m, ako ho odstr치nime
                localStorage.removeItem(pendingKey);
                console.log(LOG_PREFIX + `saveWorkDataToFirestore (${docId}): Removed pending sync key: ${pendingKey}.`);
            } else if (pendingKey) {
                console.log(LOG_PREFIX + `saveWorkDataToFirestore (${docId}): Pending sync key ${pendingKey} was not found in LS (might have been already removed or never set).`);
            }
        } catch (error) {
            console.error(LOG_PREFIX + `saveWorkDataToFirestore (${docId}): Error saving work data to Firestore:`, error.code, error.message, error);
            showErrorNotification('Chyba ukladania pracovn칳ch d치t do cloudu: ' + error.message);
            // Nech치me pendingKey, ak ukladanie zlyhalo, aby sa to sk칰silo znova cez syncPendingWorkData
            const pendingKey = getPendingSyncKeyForWorkData();
            if (pendingKey) {
                console.warn(LOG_PREFIX + `saveWorkDataToFirestore (${docId}): Pending key ${pendingKey} NOT removed due to error. Data still marked for sync.`);
                 // Ak by sme chceli, tu by sme mohli znovu explicitne ulo쬴콘 dataToSave pod pendingKey,
                 // ale _debouncedSaveWorkDataAndSync by to u mal ma콘 v LS pod hlavn칳m k쮂줷꼂m,
                 // tak쬰 syncPendingWorkData by mal pracova콘 s t칳m. D칪le쬴t칠 je, aby pendingKey zostal.
            }
        }
    }

    async function syncPendingWorkData() {
        console.log(LOG_PREFIX + "syncPendingWorkData: Attempting to sync...");
        if (!currentUser) { console.log(LOG_PREFIX + "syncPendingWorkData: Aborted - No user."); return; }
        if (!navigator.onLine) { console.log(LOG_PREFIX + "syncPendingWorkData: Aborted - Offline."); return; }

        const pendingKey = getPendingSyncKeyForWorkData();
        if (!pendingKey) { console.log(LOG_PREFIX + "syncPendingWorkData: Aborted - No pending key for current user/month."); return; }

        const pendingDataString = localStorage.getItem(pendingKey);
        if (pendingDataString) {
            console.log(LOG_PREFIX + `syncPendingWorkData: Found pending data for key ${pendingKey}.`);
            try {
                const dataToSync = JSON.parse(pendingDataString);
                dataToSync.lastUpdated = new Date().toISOString(); // V쬯y aktualizova콘 timestamp pred odoslan칤m
                console.log(LOG_PREFIX + `syncPendingWorkData: Calling saveWorkDataToFirestore for pending data.`);
                await saveWorkDataToFirestore(dataToSync, getFirestoreDocId());
                // 칔spe코n칠 odstr치nenie pendingKey sa deje v saveWorkDataToFirestore
            } catch (error) {
                // Chyba pri parsovan칤 alebo inom neo캜ak치vanom probl칠me pred volan칤m saveWorkDataToFirestore
                console.error(LOG_PREFIX + 'syncPendingWorkData: Error during sync process (before calling saveWorkDataToFirestore):', error);
            }
        } else {
            console.log(LOG_PREFIX + `syncPendingWorkData: No pending data found for key ${pendingKey}.`);
        }
    }

    // --- Event Listenery a Inicializ치cia Aplik치cie ---
    window.addEventListener('online', async () => { // Pridan칳 async pre await enableNetwork
        console.log(LOG_PREFIX + "EVENT_HANDLER: Window 'online' event triggered.");
        handleOnlineStatusChange(true);
        // Experiment치lne: Sk칰si콘 explicitne povoli콘 sie콘 pre Firestore
        try {
            console.log(LOG_PREFIX + "NET_MGMT ('online'): Attempting to ENABLE network for Firestore.");
            await enableNetwork(db);
            console.log(LOG_PREFIX + "NET_MGMT ('online'): Network for Firestore SHOULD BE enabled.");
        } catch (e) {
            console.error(LOG_PREFIX + "NET_MGMT ('online'): Error enabling network for Firestore", e);
        }
        // Oneskorenie, aby sa sie콘 a SDK mohli stabilizova콘
        setTimeout(() => {
            console.log(LOG_PREFIX + "EVENT_HANDLER ('online' timeout): Calling syncPendingWorkData().");
            syncPendingWorkData();
            if(currentUser) {
                console.log(LOG_PREFIX + "EVENT_HANDLER ('online' timeout): Calling saveAppSettingsToFirestore().");
                saveAppSettingsToFirestore();
            }
        }, 2000); // Oneskorenie 2 sekundy
    });

    window.addEventListener('offline', async () => { // Pridan칳 async pre await disableNetwork
        console.log(LOG_PREFIX + "EVENT_HANDLER: Window 'offline' event triggered.");
        handleOnlineStatusChange(false);
        // Experiment치lne: Sk칰si콘 explicitne zak치za콘 sie콘 pre Firestore
        // aby sme boli konzistentn칤, aj ke캞 by to SDK malo robi콘 samo.
        try {
            console.log(LOG_PREFIX + "NET_MGMT ('offline'): Attempting to DISABLE network for Firestore.");
            await disableNetwork(db);
            console.log(LOG_PREFIX + "NET_MGMT ('offline'): Network for Firestore SHOULD BE disabled.");
        } catch (e) {
            console.error(LOG_PREFIX + "NET_MGMT ('offline'): Error disabling network for Firestore", e);
        }
    });

    onAuthStateChanged(auth, async (user) => {
        console.log(LOG_PREFIX + 'onAuthStateChanged: Auth state changed. User:', user ? user.email : 'None');
        // ... (zvy코ok onAuthStateChanged s pr칤padn칳m 캞al코칤m logovan칤m) ...
        currentUser = user; updateUIForAuthStateChange();
        if (user) {
            const settingsLoadedFromFS = await loadUserAppSettingsFromFirestore();
            if (!settingsLoadedFromFS) { loadAppSettingsFromLocalStorage(); updateSettingsUIInputs(); if (navigator.onLine) await saveAppSettingsToFirestore(); }
        } else { loadAppSettingsFromLocalStorage(); updateSettingsUIInputs(); }
        createTable(); setupFirestoreWorkDataListener(); updatePageTitleAndGreeting();
    });

    console.log(LOG_PREFIX + "Running initializeUI()...");
    initializeUI();
    // ... (zvy코ok v치코ho k칩du - createTable, exporty, at캞. m칪쬿 ma콘 tie pridan칠 logy, ak je to potrebn칠)

  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        console.log("[KOD_1_DEBUG_SW] Attempting to register ServiceWorker...");
        navigator.serviceWorker.register('./service-worker.js')
          .then(reg => console.log('[KOD_1_DEBUG_SW] ServiceWorker Registered. Scope: ', reg.scope))
          .catch(err => console.error('[KOD_1_DEBUG_SW] ServiceWorker Reg Failed: ', err));
      });
    }
  </script>
</body>
</html>
